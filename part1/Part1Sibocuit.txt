ננתח את הסיבוכיות זמן ריצה ומקום לפי כל אחת מהפונקציות:
n = מספר השורות בקובץ
k = מספר השורות בכל חלק (chunk)
E = מספר סוגי השגיאות הייחודיות


split_large_excel_file(input_file, chunk_size=100000):
פונקציה שפותחת את קובץ האקסל וקוראת אותו חתיכות חתיכות לפי גודל הchunk_size
יש לי שם לולאת FOR שבסופו של דבר עוברת על כל השורות כיוון שאפילו שהיא מחזירה את זה בבלוקים היא עדיין צריכה לעבור על הכל בגלל הקטע הזה:
enumerate(sheet.iter_rows(values_only=True)
ולכן סיבוכית הזמן היא O(n)
לעומת זאת סיבוכית המקום היא כגודל ה CHUNKבכל פעם שאוספים chunk_size שורות, מחזירים אותן (yield
ולכן סיבוכית המקום פה היא O(K)

extract_error_value(error_string)
 הפונקציה  מקבלת מחרוזת ובודקת אם יש בה את המילה "Error:", ואז מחזירה את הערך שאחריה.
 בדיקה אם Error: קיים במחרוזת O(m), כאשר m הוא אורך המחרוזת.
 סיבוכיות זמן כוללת:
O(m) (אורך המחרוזת).
 סיבוכיות מקום:
O(1)

update_error_count(error_value, error_count)
הפונקציה מעדכנת מילון שבו כל error_value הוא מפתח, ומגדילה את המונה שלו.
סיבוכיות זמן כוללת:
O(1) לכל עדכון שגיאה.
✅ סיבוכיות מקום:
O(E) (מילון עם מספר מקסימלי של סוגי שגיאות).

read_excel(input_file, N)
מחלק את קובץ ה-Excel לחלקים (split_large_excel_file).
עבור כל חלק, קורא שורות ומעדכן מונה שגיאות (update_error_count).
בסוף, ממיין את סוגי השגיאות ומחזיר את N הנפוצות ביותר.
(מפעילה כביכול את כל הפונקציות)
סיבוכיות זמן כוללת:
O(n)+ElogE
 סיבוכיות מקום:
O(E) (מילון עם כל סוגי השגיאות).
הסבר לסיבוכיות:
יש בתוכה את הפונקציה הראשונה שהיא רצהO(n)
חיפוש שגיאות ועדכון מילון:את הפונקציה השניה שזה O(1)
מיון מילון השגיאות -ElogE

main()
מזמן אתread_excel
ולכן הסיבוכית הסופית היא:
סיבוכית זמן ריצה:O(n) (O(n)+ElogE ללא ElogE כי O(n) יותר משמעותי..)
סיבוכית מקום:O(K) במקרה שלנו זה מספר החתיכות וזה יותר משמעותי פה ממספר השגיאות כי אין הרבה
אבל יכול להיות שבמקרים אחרים זה יהיה O(E)
